// src/hooks/useMatchingGame.js
import { useState, useEffect, useCallback, useRef } from 'react';

function shuffleArray(array) {
    const newArray = [...array];
    for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
}

export function useMatchingGame(fullWordList = [], numPairsToDisplay = 6) {
    const [activeWordPairs, setActiveWordPairs] = useState([]); 
    const [spanishOptions, setSpanishOptions] = useState([]); 
    const [englishOptions, setEnglishOptions] = useState([]); 

    const [selectedSpanish, setSelectedSpanish] = useState(null); 
    const [selectedEnglish, setSelectedEnglish] = useState(null);
    
    const [gameScore, setGameScore] = useState(0);
    // sessionUsedWordIds tracks words correctly matched in the current "super-session" (until fullWordList changes)
    // to try and avoid showing them again too soon when a new board is generated by initializeNewRound.
    const [sessionUsedWordIds, setSessionUsedWordIds] = useState(new Set());
    
    const gameInitializedForCurrentList = useRef(false);

    const pickNewWords = useCallback((count, excludeIdsSet = new Set()) => {
        const newWords = [];
        const validSourceList = Array.isArray(fullWordList) ? fullWordList : [];
        
        let availablePool = validSourceList.filter(word => !excludeIdsSet.has(word.id));
        
        if (availablePool.length < count) {
            console.warn(`useMatchingGame: pickNewWords found only ${availablePool.length} fresh words (excluding ${excludeIdsSet.size}). Allowing reuse from full list.`);
            // If not enough truly "new" words, broaden the pool by allowing reuse from the full list,
            // still trying to avoid what's on the *current board* if this pick is for replacement.
            // For a new round, we might just pick from fullWordList if sessionUsedWordIds has exhausted unique options.
            availablePool = validSourceList.filter(word => !new Set(activeWordPairs.map(p=>p.id)).has(word.id)); // Fallback: pick any not currently active
            if (availablePool.length < count) { // If still not enough, just take what we can
                 console.warn(`useMatchingGame: pickNewWords fallback still found only ${availablePool.length} words.`);
            }
        }

        const shuffledPool = shuffleArray(availablePool);

        for (const word of shuffledPool) {
            if (newWords.length >= count) break;
            newWords.push(word);
        }
        return newWords;
    }, [fullWordList, activeWordPairs]); // activeWordPairs added to help pickNewWords avoid current board items in fallback

    // Function to setup a new board of words.
    const initializeNewRound = useCallback(() => {
        console.log("useMatchingGame: Initializing New Round.");
        setSelectedSpanish(null);
        setSelectedEnglish(null);
        // setGameScore(0); // Reset score only for a completely new game session, not every reshuffle if desired
                           // For now, let's keep resetting score on "New Round" button.
        setGameScore(0);
        
        // For a "New Round" button click, we want to ensure we try to get fresh words
        // so we use the current sessionUsedWordIds for exclusion.
        // If all words from fullWordList have been used in sessionUsedWordIds, pickNewWords will struggle.
        // So, if pickNewWords returns too few, we reset sessionUsedWordIds and try again.
        let newPairs = pickNewWords(numPairsToDisplay, sessionUsedWordIds);

        if (newPairs.length < numPairsToDisplay && fullWordList.length >= numPairsToDisplay) {
            console.warn(`useMatchingGame: Not enough unique words for round from session. Resetting sessionUsedWordIds & repicking.`);
            const freshSessionExclusions = new Set();
            setSessionUsedWordIds(freshSessionExclusions); // Reset for the next pick cycle
            newPairs = pickNewWords(numPairsToDisplay, freshSessionExclusions); 
        }
        
        if (newPairs.length === 0 && fullWordList.length > 0) {
            console.warn("useMatchingGame: Could not pick any pairs for new round.");
            setActiveWordPairs([]); setSpanishOptions([]); setEnglishOptions([]);
            return;
        }
        if (newPairs.length > 0 && newPairs.length < numPairsToDisplay) {
            console.warn(`useMatchingGame: Round will have ${newPairs.length} pairs.`);
        }
        
        setActiveWordPairs(newPairs);
        setSpanishOptions(shuffleArray(newPairs.map(p => ({ id: p.id, text: p.spanish, type: 'spanish', matched: false }))));
        setEnglishOptions(shuffleArray(newPairs.map(p => ({ id: p.id, text: p.english, type: 'english', matched: false }))));
        console.log("useMatchingGame: New round initialized with pairs:", newPairs);
    }, [fullWordList, numPairsToDisplay, pickNewWords, sessionUsedWordIds]); // sessionUsedWordIds is a dependency

    // Effect to initialize game ONLY when fullWordList changes its reference OR on first valid load
    useEffect(() => {
        console.log("useMatchingGame: Effect for fullWordList change or initial mount running.");
        if (fullWordList && fullWordList.length > 0 && fullWordList.length >= numPairsToDisplay) {
            console.log("useMatchingGame: fullWordList is sufficient. Initializing a new game session (resets score & used words).");
            // This call to initializeNewRound is effectively starting a "super session"
            // It should reset sessionUsedWordIds internally.
            initializeNewRound(); // It will reset score and sessionUsedWordIds due to its internal logic if we make it always reset them
            gameInitializedForCurrentList.current = true;
        } else {
            console.log("useMatchingGame: fullWordList not sufficient or empty for game. Clearing board.");
            setActiveWordPairs([]); setSpanishOptions([]); setEnglishOptions([]);
            setGameScore(0); setSessionUsedWordIds(new Set());
            gameInitializedForCurrentList.current = false;
        }
    }, [fullWordList, numPairsToDisplay]); // REMOVED initializeNewRound from here to break loop.
                                          // initializeNewRound will be called explicitly or its internal state changes won't cause this effect to re-run.
                                          // This effect now only reacts to changes in the master word list or required pairs count.

    const attemptMatch = useCallback(() => {
        if (selectedSpanish && selectedEnglish) {
            const originalPairForSpanish = activeWordPairs.find(p => p.id === selectedSpanish.id);
            let isCorrectMatch = false;

            if (originalPairForSpanish && originalPairForSpanish.id === selectedEnglish.id) {
                isCorrectMatch = true; 
            }

            if (isCorrectMatch) {
                console.log("useMatchingGame: Correct Match!", originalPairForSpanish);
                setGameScore(prev => prev + 1);
                
                // Add to sessionUsedWordIds - this helps initializeNewRound pick fresh words next time
                setSessionUsedWordIds(prev => new Set(prev).add(originalPairForSpanish.id));

                // Mark as matched in UI options
                setSpanishOptions(prevOpts => prevOpts.map(opt => opt.id === selectedSpanish.id ? {...opt, matched: true} : opt));
                setEnglishOptions(prevOpts => prevOpts.map(opt => opt.id === selectedEnglish.id ? {...opt, matched: true} : opt));
                
                // ---- MODIFIED: No immediate replacement and reshuffle of entire board ----
                // The items are now visually marked as 'matched'.
                // The user will continue matching other pairs on the board.
                // When all are matched, or when "New Round" is clicked, the board will refresh.
                console.log("useMatchingGame: Pair matched. Items will remain visually matched.");

                // Check if all currently displayed active pairs are now matched
                const updatedActivePairsStillUnmatched = activeWordPairs.filter(p => p.id !== originalPairForSpanish.id);
                if (updatedActivePairsStillUnmatched.every(p => sessionUsedWordIds.has(p.id) || spanishOptions.find(so => so.id === p.id && so.matched))) {
                     // A bit complex to check here if all on *board* are matched,
                     // as items are not removed from spanishOptions/englishOptions immediately.
                     // A simpler check: if all items in `activeWordPairs` are now in `sessionUsedWordIds`
                     let allActiveAreNowSessionMatched = true;
                     for (const ap of activeWordPairs) {
                         if (!sessionUsedWordIds.has(ap.id) && ap.id !== originalPairForSpanish.id) { // Check against current session + the one just matched
                             allActiveAreNowSessionMatched = false;
                             break;
                         }
                     }
                     if (allActiveAreNowSessionMatched || activeWordPairs.length === 1) { // If only one pair was left and it got matched
                        console.log("useMatchingGame: All pairs on current board appear to be matched! User can click 'New Round'.");
                     }
                }

            } else {
                console.log("useMatchingGame: Incorrect Match.");
                // TODO: Add state/callback for visual feedback for incorrect match in UI
            }
            setSelectedSpanish(null);
            setSelectedEnglish(null);
        }
    }, [selectedSpanish, selectedEnglish, activeWordPairs, sessionUsedWordIds, setSessionUsedWordIds, setGameScore, setSpanishOptions, setEnglishOptions]); // Removed pickNewWords, numPairsToDisplay, fullWordList

    const handleSpanishSelection = useCallback((spanishItem) => {
        if (spanishItem.matched) return; 
        setSelectedSpanish(spanishItem);
    }, []);

    const handleEnglishSelection = useCallback((englishItem) => {
        if (englishItem.matched) return; 
        setSelectedEnglish(englishItem);
    }, []);

    useEffect(() => {
        if (selectedSpanish && selectedEnglish) {
            attemptMatch();
        }
    }, [selectedSpanish, selectedEnglish, attemptMatch]);

    return {
        spanishOptions,
        englishOptions,
        selectedSpanish,
        selectedEnglish,
        gameScore,
        handleSpanishSelection,
        handleEnglishSelection,
        initializeNewRound, // This is for the "New Round / Reshuffle" button
        activePairCount: activeWordPairs.length,
        allWordsCount: fullWordList.length,
    };
}